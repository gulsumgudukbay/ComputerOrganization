####	lab1(1).asm is a simple program##	that has sequential operations##        ##########################################					##		text segment		##					##########################################	.text		.globl __start __start:		# execution starts here	la 	$a0,prompt	li 	$v0,4	# prints the prompt	syscall		li 	$v0, 5	# reads an integer	syscall		lw	$t0, word	# t0 = word	#li	$t1, 5		# loads the constant 5 into register $t1	lw	$t1, word	# loads the word stored in word into register $t1	lui	$t7, 0x1000	# large constant	ori	$t7, $t7, 0x8004		lw	$t5, ($t7)			addi	$t4, $0, 2	# t4 = 2	sll	$t4, $t4, 3	# t4 = 16	add	$v0, $t4, $t1			lui	$t3, 98	# large constant	ori	$t3, $t3, 8		sub	$t3, $t3, $t5	# subtract $t3 = $t3-$t7		sub	$v0, $t3, $v0		move	$a0,$v0	# print integer result	li	$v0,1	# using syscall 1	syscall		li $v0,10	syscall		# bye bye##########################################					##     		data segment		##					##########################################	.dataprompt:	.asciiz "Enter an integer: "endl:	.asciiz "\n"word:	.word 42value_stored: .word 394#### end of lab1(1).asm####	lab1(2).asm is a simple program that prompts the user ##	to enter an integer N, and computes the factorial of##	the integers from 0 to N.##        ##########################################					##		text segment		##					##########################################	.text		.globl __start __start:		# execution starts here	la 	$a0, prompt	li 	$v0, 4	# prints the prompt	syscall		move	$t3, $0	# initialize t3 to outer_index = 0		li 	$v0, 5	# reads an integer	syscall		move	$t4, $v0 # N	addi	$t4, $t4, 1 #N+1 for correct loop termination	outer_loop:		beq	$t3, $t4, end_outer_loop	# exit loop when index = N		addi	$t2, $0, 1	# initialize t2 to inner_index = 0	addi	$t5, $0, 1	#initialize the factorial to 1	addiu	$t6, $t3, 1	#N+1		inner_loop:	beq	$t6, $t2, end_inner_loop	mul	$t5, $t5, $t2	add	$t2, $t2, 1	# increment inner index	b	inner_loop	end_inner_loop:		move	$a0, $t5	# print integer result	li	$v0, 1	# using syscall 1	syscall		la 	$a0, space	li 	$v0, 4	# prints space	syscall		add	$t3, $t3, 1	# increment outer index	b	outer_loopend_outer_loop:	li	$v0, 10 # bye bye	syscall	##########################################					##     		data segment		##					##########################################	.dataprompt:	.asciiz "Enter an integer N: "result:	.asciiz "The factorials of integers 0 upto N are: "space:	.asciiz " "#### end of lab1(2).asm
####	lab1(4).asm is a program that sorts##	user - inputted integers and searches##	among them##        ##########################################					##		text segment		##					##########################################	.text		.globl __start __start:		# execution starts here	la 	$a0, prompt	li 	$v0, 4	# prints the prompt	syscall		li 	$v0, 5	# reads an integer	syscall		add	$t1, $0, $v0 # t1 = N = user input	move	$t0, $0	# initialize t0 to index = 0	la	$t2, array # get the address of array		la 	$a0, prompt2	li 	$v0, 4	# prints the prompt	syscall	loop:		beq	$t0, $t1, loop_end # exit loop when index = N		li 	$v0, 5	# reads an integer	syscall		sw	$v0, ($t2)	addi	$t2, $t2, 4 # calculate next elements address	add	$t0, $t0, 1	# increment index	j	 loop		loop_end:	addi	$t0, $0, 0 #initialize t0 = index = 0 again for print loop		la 	$a0, msg1	li 	$v0, 4	# prints msg1	syscall		la 	$a0, open_bracket	li 	$v0, 4	# prints open bracket	syscall	la	$t2, array # get the address of arrayprint_loop:	beq 	$t0, $t1, print_loop_end # did the index come to the end?		lw	$a0, ($t2) # print integer at the index	li	$v0, 1	syscall		la 	$a0, space	li 	$v0, 4	# prints space	syscall		addi	$t0, $t0, 1 # advance index	addi	$t2, $t2, 4 # calculate the next element's address		j print_loop # repeat the loopprint_loop_end:	la 	$a0, close_bracket	li 	$v0, 4	# prints close bracket	syscall	bubble_sort: 		la	$s0, array	# array address	add	$s1, $0, $t1	# array size	addi	$s2, $0, 0	# outer loop indexouter_loop:	addi	$t4, $t2, -1	# size-1 for loop termination	slt	$t0, $s2, $t4	beqz	$t0, end_outer_loop		addi	$s3, $0, 0	# inner loop index	inner_loop:		addi	$t4, $t2, -1		sub	$t4, $t4, $s2		slt	$t0, $s3, $t4		beqz	$t0, end_inner_loop				sll	$t3, $s3, 2 # load array[innerIndex]		add	$t5, $s0, $t3		lw	$t2, 0($t5)				addi	$t6, $t5, 4 # load array[innerIndex+1]		lw	$t7, 0($t6)			sgt	$t0, $t2, $t7		beqz	$t0, not_greater					move $a0, $s0	#assigning the arguments of the swap function 		move $a1, $s3 		addi $t0, $s3, 1 		move $a2, $t0 		jal swap 						not_greater:		addi	$s3, $s3, 1	#increment inner loop address		b	inner_loop			end_inner_loop:	addi	$s2, $s2, 1	b	outer_loopend_outer_loop:		j	print_sortedswap:	sll $t8, $a1, 2 # calcualate address of element 1	add $t8, $a0, $t8	sll $t9, $a2, 2 # calculate address of element 2	add $t9, $a0, $t9	lw $s5, 0($t8) #swap elements	lw $s6, 0($t9)	sw $s5, 0($t9)	sw $s6, 0($t8)	jr $ra				######## Print sorted array #######print_sorted:	la	$t2, array # get the address of array		addi	$t0, $0, 0 #initialize t0 = index = 0 again for print loop		la 	$a0, msg2	li 	$v0, 4	# prints msg2	syscall		la 	$a0, open_bracket	li 	$v0, 4	# prints open bracket	syscall	print_loop_after:	beq $t0, $t1, print_loop_end_after # did the index come to the end?		lw $a0, ($t2) # print integer at the index	li $v0, 1	syscall		la 	$a0, space	li 	$v0, 4	# prints space	syscall		addi	$t0, $t0, 1 # advance index	addi	$t2, $t2, 4 # calculate the next element's address		j print_loop_after # repeat the loop	print_loop_end_after:	la 	$a0, close_bracket	li 	$v0, 4	# prints close bracket	syscall			do:		la 	$a0, menu	li 	$v0, 4	# prints menu	syscall				li 	$v0, 5	# reads an integer	syscall		add	$s7, $0, $v0 # s7 = user choice		#if block	slti	$s5, $s7, 1	sgt	$s6, $s7, $t1	or	$s5, $s5, $s6 	beqz 	$s5, choice1 invalidInput:	#invalid input block 	la 	$a0, invalid_input	li 	$v0, 4	# prints exit message	syscall		b end_if	 choice1: #mean value 	bne	$s7, 1, choice2 	 	la 	$a0, one	li 	$v0, 4	# prints 1	syscall	 	 	 	addi	$s0, $0, 0 #initialize the result to 0 mean_loop:	beq 	$t0, $t1, mean_loop_end # did the index come to the end?		add	$s0, $s0, $t2	#sum values	addi	$t0, $t0, 1 # advance index	addi	$t2, $t2, 4 # calculate the next element's address		j	mean_loop # repeat the loop	mean_loop_end:	div	$s0, $s0, $t1	move	$a0, $s0 # print integer result	li	$v0, 1	 # using syscall 1	syscall 	 	 	b end_if 	 choice2: #median value  	bne	$s7, 2, choice3 	 	la 	$a0, two	li 	$v0, 4	# prints 2	syscall			addi	$t9, $0, 2 #calculating the adress of the middle value	div	$t9, $t1, $t9	sll	$t9, $t9, 2	add	$t9, $t2, $t9 	move	$a0, $t9 # print integer result	li	$v0, 1	 # using syscall 1	syscall  	b end_if 	  choice3: #smallest value  	bne	$s7, 3, choice4  	  	la 	$a0, three	li 	$v0, 4	# prints 3	syscall			lw $a0, ($t2) # print integer at the beginning of the array	li $v0, 1	syscall	 	b end_if 	 choice4: #largest value 	bne	$s7, 4, choice5 	 	la 	$a0, four	li 	$v0, 4	# prints 4	syscall				subi	$t4, $t1, 4 #calculate the adress of the last element 		lw $a0, ($t4) # print integer at the last place of the array	li $v0, 1	syscall		b end_if	 choice5: #average of smallest, median, and largest values  	bne	$s7, 5, choice6  	  	la 	$a0, five	li 	$v0, 4	# prints 5	syscall		 	b end_if 	  choice6: #3rd value* 	bne	$s7, 6, choice7 	 	la 	$a0, six	li 	$v0, 4	# prints 6	syscall	  	b end_if 	 choice7: #2nd-to-last value*  	bne	$s7, 7, choice8  	  	la 	$a0, seven	li 	$v0, 4	# prints 7	syscall			b end_if	 choice8: #number of negative values  	bne	$s7, 8, choice9  	  	la 	$a0, eight	li 	$v0, 4	# prints 8	syscall	 	b end_if 	 choice9: #average of lower half-list* 	bne	$s7, 9, choice10 	 	la 	$a0, nine	li 	$v0, 4	# prints 9	syscall		 	b end_if 	 choice10: #average of upper half-list*	bne	$s7, 10, else		la 	$a0, ten	li 	$v0, 4	# prints 10	syscall	  	b end_if else:	b end	end_if: 	bne	$s7, 11, doend:	la 	$a0, msg3	li 	$v0, 4	# prints exit message	syscall			li	$v0, 10	syscall		# bye bye##########################################					##     		data segment		##					##########################################	.dataarray:	.space 2000    #500 element integer arrayprompt:	.asciiz "\nEnter the number of integers you want to enter: "prompt2:.asciiz "\nEnter the integers: "msg1:.asciiz "\nUnsorted array:\t"msg2:.asciiz "\nSorted array:\t"msg3:.asciiz "\nYou have exited the program, bye!\t"invalid_input:.asciiz "\nYou have entered an invalid input, please enter an integer between 1 and 11 (both inclusive)\t"	open_bracket: .asciiz "[ "close_bracket: .asciiz "]"space: .asciiz " "menu: .asciiz "\nPlease choose one of the choices below by entering its number:\n(1)mean value\n(2)median value\n(3)smallest value\n(4)largest value\n(5)average of smallest, median, and largest values\n(6)3rd value*, \n(7)2nd-to-last value*\n(8)number of negative values\n(9)average of lower half-list*\n(10)average of upper half-list*\n(11) none of these\n"one: .asciiz "The mean value is: "two: .asciiz "The median value is: "three: .asciiz "The smallest value is: "four: .asciiz "The largest value is: "five: .asciiz "The average of smallest, median, and largest values is: "six: .asciiz "The 3rd value is: "seven: .asciiz "The 2nd-to-last value is: "eight: .asciiz "The number of negative values is: "nine: .asciiz "The average of lower half-list is: "ten: .asciiz "The average of upper half-list is: "#### end of lab1(4).asm